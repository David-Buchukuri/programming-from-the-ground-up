## Know the Concepts

#### What does if mean if a line in the program starts with the ’#’ character?

It means that it's a comment not code. It will be ignored by assembler. Comments' purpose is to document the code for other programmers or for ourselves.

#### What is the difference between an assembly language file and an object code file?

Object file code has binary instructions(machine code) in itself. This file is usually generated by an assembler program. In assembly language file, there is an assembly code which is written by a programmer.

#### What does the linker do?

Linker includes code from other files if it's specified and also it adds some information to our object file so an operating system knows how to execute it.

#### How do you check the result status code of the last program you ran?

By running `echo $?` in terminal.

#### What is the difference between `movl $1, %eax` and `movl 1, %eax` ?

In the first instruction we write in %eax register a literal value 1.
In the second instruction we write in %eax register a value which is in a word located at the address 1.

#### Which register holds the system call number?

%eax

#### What are indexes used for?

Indexes are used for accessing different elements in the set of elements. With indexes we can specify, how many times should we add the length of the element in a set, to the base address of the set to get the address of our desired element.

#### Why do indexes usually start at 0?

Because the first element in a set is the address of the set. As I answered above, index denotes how "far" we are from the base address. In the case of the first element, "distance" from base address is 0.

#### If I issued the command movl data_items(,%edi,4), %eax and data_items was address 3634 and %edi held the value 13, what address would you be using to move into %eax ?

3634 + 13 \* 4

#### List the general-purpose registers.

%eax, %ebx, %ecx, %edx, %edi, %esi.

#### What is the difference between movl and movb ?

movl tries to move 32 bit value starting from the specified address(l stands for a long).
movb tries to move 8 bit value starting from the specified address(b stands for a byte).

#### What is flow control?

Flow control is a mechanism that allows us to control the execution of a program based on certain conditions we set. It enables us to determine the order in which instructions are executed, allowing the program to make decisions, repeat certain operations, or skip over some instructions. For example, part of a program might check if some condition is true. if it is, the program might jump to another instruction, potentially skipping some instructions or going backwards to repeat others.

#### What does a conditional jump do?

In conditional jump, we specify a condition and a part of the program we want to continue executing instructions from.
If the condition is satisfied, program will continue to execute instructions from specified location, if not, program will carry on with the next instruction. Usually we make comparison of operands in different instruction, after which appropriate cpu flags are set with certain values. jump command checks those cpu flags to determine if condition (less, grater, equal, ...) specified in jump command is satisfied by those operands(second operand is compared to the first one).

#### What things do you have to plan for when writing a program?

Along with the main logic

- How many variables will be used.
- What data will each variable hold.
- How much sttorage will we need and if it's possible to use only registers.

#### Go through every instruction of the max.asm program and list what addressing mode is being used for each operand.

```
.section .data

data_array:
.long 1, 2, 9, 5, 2, 9, 125, 0

.section .text
.global _start

update_max_element:
    movl %eax, %ebx
    jmp iterate

_start:

movl $0, %edi
movl data_array(, %edi, 4), %ebx
movl %ebx, %eax

loop:
    cmpl $0, %eax
    je exit

    cmpl %ebx, %eax
    jg update_max_element

    iterate:
    incl %edi
    movl data_array(, %edi, 4), %eax
    jmp loop


exit:
    movl $1, %eax
    int $0x80
```

- movl %eax, %ebx - register addressing mode for the both operands
- movl $0, %edi - immediate mode for the first operand, register addressing mode for the second one
- movl data_array(, %edi, 4), %ebx - indexed addressing mode, register addressing mode
- movl %ebx, %eax - register addressing mode for the both
- cmpl $0, %eax - immediate for the first one, register addressing mode for the other one
- cmpl %ebx, %eax - register addressing mode for the both
- incl %edi - register addressing mode
- movl data_array(, %edi, 4), %eax - indexed addressing mode, register addressing mode
- movl $1, %eax - immediate mode, register addressing mode
- int $0x80 - immediate mode

## Use the Concepts

#### What would the instruction movl \_start, %eax do? Be specific, based on your knowledge of both addressing modes and the meaning of \_start . How would this differ from the instruction movl $\_start, %eax ?

`movl _start, %eax` will write in %eax whatever value is stored in the word with an address of \_start.

`movl $\_start, %eax` will write in %eax memory address of the \_start.

## Going Further

#### Modify the first program to leave off the int instruction line. Assemble, link, and execute the new program. What error message do you get. Why do you think this might be?

I am getting a segmentation fault error. It's probably because program does not terminate. Program probably reads and tries to execute instructions from memory which is beyond instructions which we wrote and because of that, an error is happening.

#### So far, we have discussed three approaches to finding the end of the list - using a special number, using the ending address, and using the length count. Which approach do you think is best? Why? Which approach would you use if you knew that the list was sorted? Why?

I think providing array's lengths is the best way because of it's simplicity and universality. If we use a special number for termination, that means we can't use that number anywhere in the list. That's not flexible.
About an ending address, user can't provide ending address because there is no way of knowing it before a program runs.

For a sorted list, I would use the array length approach, because it's straightforward and simple.
